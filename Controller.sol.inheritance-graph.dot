digraph "" {
AccessControl -> Context [ label="1" ];
AccessControl -> IAccessControl [ label="2" ];
AccessControl -> ERC165 [ label="3" ];
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

AccessControlEnumerable -> IAccessControlEnumerable [ label="1" ];
AccessControlEnumerable -> AccessControl [ label="2" ];
AccessControlEnumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControlEnumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMember(bytes32,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleMemberCount(bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roleMembers</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'hasRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'getRoleAdmin(bytes32)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'grantRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'revokeRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.<BR/>'renounceRole(bytes32,address)' collides in inherited contracts IAccessControl, AccessControl where AccessControl is chosen.</font></TD></TR></TABLE> >];

IAccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

IAccessControlEnumerable -> IAccessControl;
IAccessControlEnumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControlEnumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getRoleMember(bytes32,uint256)</TD></TR><TR><TD align="left">    getRoleMemberCount(bytes32)</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

ReentrancyGuard[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ReentrancyGuard</B></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonReentrant()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _NOT_ENTERED</TD></TR><TR><TD align="left">    _ENTERED</TD></TR><TR><TD align="left">    _status</TD></TR></TABLE> >];

ERC20 -> Context [ label="1" ];
ERC20 -> IERC20 [ label="2" ];
ERC20 -> IERC20Metadata [ label="3" ];
ERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transfer(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    allowance(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left">    increaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    decreaseAllowance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(address,uint256)</TD></TR><TR><TD align="left">    _approve(address,address,uint256)</TD></TR><TR><TD align="left">    _spendAllowance(address,address,uint256)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _allowances</TD></TR><TR><TD align="left">    _totalSupply</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

IERC20Metadata -> IERC20;
IERC20Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _HEX_SYMBOLS</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

EnumerableSet[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableSet</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _add(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableSet.Set)</TD></TR><TR><TD align="left">    _at(EnumerableSet.Set,uint256)</TD></TR><TR><TD align="left">    _values(EnumerableSet.Set)</TD></TR><TR><TD align="left">    add(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    remove(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    contains(EnumerableSet.Bytes32Set,bytes32)</TD></TR><TR><TD align="left">    length(EnumerableSet.Bytes32Set)</TD></TR><TR><TD align="left">    at(EnumerableSet.Bytes32Set,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.Bytes32Set)</TD></TR><TR><TD align="left">    add(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    remove(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    contains(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    length(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.AddressSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    add(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    remove(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    length(EnumerableSet.UintSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    values(EnumerableSet.UintSet)</TD></TR></TABLE> >];

Controller -> RewardsManager [ label="1" ];
Controller -> ErrorTracker [ label="2" ];
Controller[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Controller</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    initTokenRoles()</TD></TR><TR><TD align="left">    getTargetICEPrice()</TD></TR><TR><TD align="left">    getICEPrice()</TD></TR><TR><TD align="left">    getSTMPrice()</TD></TR><TR><TD align="left">    getICEPoolICESize()</TD></TR><TR><TD align="left">    getICEPoolH2OSize()</TD></TR><TR><TD align="left">    getSTMPoolSTMSize()</TD></TR><TR><TD align="left">    getSTMPoolH2OSize()</TD></TR><TR><TD align="left">    previewSwapH2OForICE(uint256)</TD></TR><TR><TD align="left">    previewSwapICEForH2O(uint256)</TD></TR><TR><TD align="left">    previewSwapH2OForSTM(uint256)</TD></TR><TR><TD align="left">    previewSwapSTMForH2O(uint256)</TD></TR><TR><TD align="left">    swapH2OForICE(uint256)</TD></TR><TR><TD align="left">    swapICEForH2O(uint256)</TD></TR><TR><TD align="left">    swapH2OForSTM(uint256)</TD></TR><TR><TD align="left">    swapSTMForH2O(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    onRewardsClaimed()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    calculateError()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    applyError(int256,int256,uint256)</font></TD></TR><TR><TD align="left">    _updatePoolSize()</TD></TR><TR><TD align="left">    _totalH2O()</TD></TR><TR><TD align="left">    _scaleChangeWithTime(int256,uint256,uint256)</TD></TR><TR><TD align="left">    _updateTargetICEPrice(int256,uint256)</TD></TR><TR><TD align="left">    _updateSTMPrice(int256,uint256)</TD></TR><TR><TD align="left">    _updateCondensationRate(int256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    _icePool<font color="blue" POINT-SIZE="10"> (VirtualPool)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _stmPool<font color="blue" POINT-SIZE="10"> (VirtualPool)</font></TD></TR><TR><TD align="left">    _dInitialSTMSupply</TD></TR><TR><TD align="left">    _dLastTotalH2O</TD></TR><TR><TD align="left">    _dTargetICEPrice</TD></TR></TABLE> >];

VirtualPool -> ReentrancyGuard [ label="1" ];
VirtualPool -> Ownable [ label="2" ];
VirtualPool[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>VirtualPool</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    priceA()</TD></TR><TR><TD align="left">    setPriceA(uint256)</TD></TR><TR><TD align="left">    priceB()</TD></TR><TR><TD align="left">    setPriceB(uint256)</TD></TR><TR><TD align="left">    scalePools(uint256)</TD></TR><TR><TD align="left">    previewSwapAB(uint256)</TD></TR><TR><TD align="left">    swapAB(uint256,address)</TD></TR><TR><TD align="left">    previewSwapBA(uint256)</TD></TR><TR><TD align="left">    swapBA(uint256,address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    calcSwapAmount(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    swap(ERC20MintableBurnable,ERC20MintableBurnable,uint256,uint256,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    tokenA<font color="blue" POINT-SIZE="10"> (ERC20MintableBurnable)</font></TD></TR><TR><TD align="left">    tokenB<font color="blue" POINT-SIZE="10"> (ERC20MintableBurnable)</font></TD></TR><TR><TD align="left">    poolSizeA</TD></TR><TR><TD align="left">    poolSizeB</TD></TR></TABLE> >];

ERC20MintableBurnable -> ERC20 [ label="1" ];
ERC20MintableBurnable -> AccessControlEnumerable [ label="2" ];
ERC20MintableBurnable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20MintableBurnable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left">    mint(address,uint256)</TD></TR><TR><TD align="left">    burn(address,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    MINTER_BURNER_ROLE</TD></TR></TABLE> >];

ERC20Reward -> ERC20MintableBurnable;
ERC20Reward[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Reward</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    claimableReward(address)</TD></TR><TR><TD align="left">    claimReward(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _reward(address)</TD></TR><TR><TD align="left">    _newReward(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _iLastRewardTimes</TD></TR><TR><TD align="left">    _dClaimableReward</TD></TR></TABLE> >];

ErrorTracker[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ErrorTracker</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getLastError()</TD></TR><TR><TD align="left">    getAccumulatedError()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    calculateError()</TD></TR><TR><TD align="left">    applyError(int256,int256,uint256)</TD></TR><TR><TD align="left">    updateError()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _dLastError</TD></TR><TR><TD align="left">    _dAccumError</TD></TR><TR><TD align="left">    _iLastTime</TD></TR></TABLE> >];

IceWaterTokens[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IceWaterTokens</B></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    iceToken<font color="blue" POINT-SIZE="10"> (IceToken)</font></TD></TR><TR><TD align="left">    h2oToken<font color="blue" POINT-SIZE="10"> (H2OToken)</font></TD></TR><TR><TD align="left">    stmToken<font color="blue" POINT-SIZE="10"> (SteamToken)</font></TD></TR></TABLE> >];

RewardsManager -> IceWaterTokens;
RewardsManager[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>RewardsManager</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    annualMeltRate()</TD></TR><TR><TD align="left">    annualCondensationRate()</TD></TR><TR><TD align="left">    claimableH2OFromICE()</TD></TR><TR><TD align="left">    claimableH2OFromSTM()</TD></TR><TR><TD align="left">    claimRewards(bool,bool)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    onRewardsClaimed()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    meltRate</TD></TR><TR><TD align="left">    condensationRate</TD></TR></TABLE> >];

UFixedPoint[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UFixedPoint</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    mul(uint256,uint256)</TD></TR><TR><TD align="left">    div(uint256,uint256)</TD></TR><TR><TD align="left">    toDecimal(uint256)</TD></TR><TR><TD align="left">    toInteger(uint256)</TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR></TABLE> >];

SFixedPoint[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SFixedPoint</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    mul(int256,int256)</TD></TR><TR><TD align="left">    div(int256,int256)</TD></TR><TR><TD align="left">    toDecimal(int256)</TD></TR><TR><TD align="left">    toInteger(int256)</TD></TR><TR><TD align="left">    max(int256,int256)</TD></TR><TR><TD align="left">    min(int256,int256)</TD></TR></TABLE> >];

H2OToken -> ERC20MintableBurnable;
H2OToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>H2OToken</B></TD></TR></TABLE> >];

IceToken -> ERC20Reward;
IceToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IceToken</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _afterTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _dTransferTax</TD></TR></TABLE> >];

SteamToken -> ERC20Reward;
SteamToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SteamToken</B></TD></TR></TABLE> >];

}